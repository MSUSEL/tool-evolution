import os
import subprocess
import json
import time
import concurrent.futures
import re

###
# Define Helper Functions
###

def run(file_name, release):
    # create command string
    command = "cve-bin-tool " + os.path.join(path_to_binary, file_name)
    # run command and save results into p
    p = subprocess.run(command, shell=True, capture_output=True)
    # count the vulnerabilities detected by cve-bin-tool
    try:
        table = pull_table(p.stdout.decode(), release)
    except:
        table = ["FAILURE IN TABLE READ"]

    return {
        'file_name': file_name,
        'release': release,
        'table': table
    }
        

def pull_table(output, version):
    if (version == "1.0"):
        return pull_table_version_one(output)
    elif (version >= "2.2"):
        return parse_table(output, 6)
    else:
        return parse_table(output, 5)

def parse_table(output, columns):
    matches = re.findall(r'(?<=│)\s*(.+?)\s*(?=│)', output)
    matches = clean_strings(matches)
    # skip header lines
    matches = follows_new_found(matches)
    return list_to_table(matches, columns)

def pull_table_version_one(output):
    results = []
    pattern = r"\|([^|]*)\|([^|]*)\|([^|]*)\|([^|]*)\|"
    for line in output.split("\n"):
        match = re.search(pattern, line)
        if match:
            data1 = match.group(1)
            data2 = match.group(2).strip()
            data3 = match.group(3).strip()
            data4 = match.group(4).strip()
            if ((len(data1) > 1) and (data1[1] != ' ')):
                results.append([data1.strip(), data2, data3, data4])
    return results

def clean_strings(arr):
    results = []
    for string in arr:
        if (string[0] == '│'):
            results.append(string[2:])
        else:
            results.append(string)
    return results

def follows_new_found(arr):
    newFoundIndex = -1
    for (index, string) in enumerate(arr):
        if (string.startswith("NewFound")):
            newFoundIndex = index
    # Take everything after that elemnt
    return arr[newFoundIndex + 1:]

def list_to_table(arr, row_length):
    results = []
    row = []
    for el in arr:
        row.append(el)
        if (len(row) == row_length):
            results.append(row)
            row = []
    return results

###
# Initialize Variables
###

# Hardcoded for now. Data is from https://pypi.org/project/cve-bin-tool/#history
#   Note: Ignoring Pre-releases: "2.0a0", "3.1rc2", "3.1rc3"
#   Other Note (01/04/23 - Travis): Can't get 3.2 or 3.2rc0 to work 
pip_releases = ['3.2', '3.2rc0', '3.1.2', '3.1.1', '3.1', '3.0', '2.2.1',\
                                '2.2', '2.1.post1', '2.1', '2.0', '1.1', '1.0']
CANNOT_READ_OUTPUT_ERROR_CODE = -101

# Load File names from binary
path_to_binary = "./01_acquisition/01_input/binaries"
binary_files = os.listdir(path_to_binary)

# Initialize results dictionary
results = {}
for file_name in binary_files:
    results[file_name] = {}

###
# Display Program Title
###
print("CVE BIN TOOL Runner")
print("===================", end='\n\n')

###
# Calculate Scores
###

# Run once before multithreading to let the tool update its database
## works best if cve-bin-tool is on version 3.1.1
print("Updating database...")

print("cve-bin-tool " + os.path.join(path_to_binary, binary_files[0]))
j = subprocess.run("cve-bin-tool " + os.path.join(path_to_binary, binary_files[0]),\
        shell=True, capture_output=True)
print(j.stderr.decode())


###
# Make Threads that run cve-bin-tool on each binary
###
for release in pip_releases:

    print("\nDownloading Release "+release)
    # download that version of cve
    j = subprocess.run( "pip install cve-bin-tool==" + release, shell=True, capture_output=True )
    print(j.stdout.decode())

    # Make thread pool
    executer = concurrent.futures.ThreadPoolExecutor(max_workers=None)

    runs = []
    print("Starting to make Threads\n")
    # Add all threads to pool, pool handles running only the max workers at once
    for file_name in binary_files:
        runs.append(executer.submit(run, file_name, release))
    
    # As threads finish, print the vulnerabilities 
    for r in concurrent.futures.as_completed(runs):
        result = r.result()
        file_name = result['file_name']
        release = result['release']
        vulns = result['table']
        results[file_name][release] = vulns
        print("found %d vulnerabilities in %s using release %s" \
            % (len(vulns), file_name, release))
        

###
# OutputResults To File
###
# writing to incremental because this data may not be a product (when testing)
with open('./01_acquisition/03_incremental/cve_bin_tool_enumerated_' + str(int(time.time())) + '.json', \
        'w', encoding='utf-8') as output_file:
    json.dump(results, output_file, ensure_ascii=False, indent=4)


###
# End Program
###
print("\nProgram End")
